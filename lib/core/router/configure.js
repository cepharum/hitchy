/**
 * (c) 2017 cepharum GmbH, Berlin, http://cepharum.de
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 cepharum GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @author: cepharum
 */

"use strict";

const Parser = require( "path-to-regexp" );
const Debug  = require( "debug" )( "debug" );

/**
 * Provides router processing some current request using configured routes.
 *
 * @this HitchyAPI
 * @param {HitchyOptions} options
 * @returns {Function}
 */
module.exports = function( options ) {
	const api = this;

	return _routingConfigure;



	/**
	 * Initializes sorted routing table from routes provided in configuration
	 *
	 * @param {HitchyComponentHandle[]} modules
	 * @param {HitchyRouteComponentTables[]} modulePolicies
	 * @param {HitchyRouteComponentTables[]} moduleRoutes
	 */
	function _routingConfigure( modules, modulePolicies, moduleRoutes ) {
		let methods, sequence;

		// compile routes selecting policies to process on every request
		methods = {};

		sequence = _combineIntoSingleList( modulePolicies, true );
		sequence = _normalizeList( sequence, modules, methods, true );

		api.router.policies = _groupByMethodAndPrefix( sequence, Object.keys( methods ) );


		// compile routes selecting responder
		methods = {};

		sequence = _combineIntoSingleList( moduleRoutes, false );
		sequence = _normalizeList( sequence, modules, methods, false );

		api.router.routes = _groupByMethodAndPrefix( sequence, Object.keys( methods ) );
	}

	/**
	 * Combines routes defined by discovered components with custom routes in
	 * current project and blueprint routes injected due to controllers found in
	 * project and modules.
	 *
	 * @param {HitchyRouteComponentTables[]} componentRouting
	 * @param {boolean} isProcessingPolicies true to process policies' definitions
	 * @returns {HitchyRouteDescriptorSet[]}
	 * @private
	 */
	function _combineIntoSingleList( componentRouting, isProcessingPolicies ) {
		let length = componentRouting.length;
		let merged = new Array( length * 2 + 2 );
		let beforeIndex = 0;
		let afterIndex = length + 2;

		// simultaneously deploy before- and after-routes of modules to start &
		// end of resulting list
		for ( ; beforeIndex < length; beforeIndex++, afterIndex++ ) {
			let routes = componentRouting[beforeIndex] || {};

			merged[beforeIndex] = routes.before || {};
			merged[afterIndex] = routes.after || {};
		}

		// insert project's custom routes right before ...
		merged[beforeIndex++] = api.runtime.config[isProcessingPolicies ? "policies" : "routes"] || {};

		// ... blueprint routes generated by optionally available model component
		merged[beforeIndex] = api.components.model && api.components.model[isProcessingPolicies ? "policies" : "routes"]() || {};


		return merged;
	}


	/**
	 * Normalizes every route in every segment to have equivalent structure for
	 * every route.
	 *
	 * @param {HitchyRouteDescriptorSet[]} segments
	 * @param {HitchyComponentHandle[]} componentHandles
	 * @param {object<string,boolean>} methods collects all methods used in processed routes
	 * @param {boolean} isProcessingPolicyRoutes true on processing policy routings
	 * @returns {HitchyRouteDescriptorSet[]}
	 * @private
	 */
	function _normalizeList( segments, componentHandles, methods, isProcessingPolicyRoutes ) {
		const routePtn  = /^(?:(\S+)\s+)?(\/.*)$/;
		const prefixPtn = /^([^*(:]*)/;

		// compile list of names of component related to either segment in list
		let componentNames = componentHandles.map( handle => handle.name );

		componentNames = componentNames
			.concat( "<project>", "<blueprint>" )
			.concat( componentNames );

		// process every listed segment of routes
		for ( let i = 0, numSegments = segments.length; i < numSegments; i++ ) {
			let rawRoutes = segments[i];
			let componentName = componentNames[i];

			// compile every route in current segment and drop invalid
			let sources = Object.keys( rawRoutes );
			let numRoutes = sources.length;
			let compiledRoutes = new Array( numRoutes );
			let write = 0;

			for ( let read = 0; read < numRoutes; read++ ) {
				let source = sources[read];

				// compile single route
				let route = _compileRouteSource( source );
				if ( route ) {
					route.target = _compileTarget( rawRoutes[source], isProcessingPolicyRoutes );
					if ( route.target ) {
						route.component = componentName;
						compiledRoutes[write++] = route;
					}
				}
			}

			compiledRoutes.splice( write, numRoutes - write );

			// replace uncompiled routes of current segment with compiled valid routes
			segments[i] = compiledRoutes;
		}

		return segments;


		/**
		 * Creates route source from provided source description.
		 *
		 * @param {string} pattern
		 * @returns {?HitchyRouteSource}
		 * @private
		 */
		function _compileRouteSource( pattern ) {
			let match = routePtn.exec( String( pattern || "" ).trim() );
			if ( !match ) {
				Debug( "ignoring invalid route %s", pattern );
				return null;
			}

			// extract method selected in route
			let method = match[1] !== undefined ? match[1].toUpperCase() : false;
			if ( !method || method === "ALL" ) {
				method = "*";
			}

			// track all methods used in routes
			methods[method] = true;

			let route = {
				method: method,
			};

			let keys = [];
			let parsed = Parser( match[2], route.keys, {
				sensitive: true,    // match path case-sensitively
			} );

			match = prefixPtn.exec( match[2] );
			let prefix = match[1].replace( /\/$/, "" );

			return { method, pattern: parsed, keys, prefix };
		}

		/**
		 *
		 * @param {HitchyRouteTargetDescriptor} target
		 * @param {boolean} processPolicies true to process policies' definitions
		 * @returns {?HitchyRouteTargetDescriptorReference}
		 * @private
		 */
		function _compileTarget( target, processPolicies ) {
			switch ( typeof target ) {
				case "string" :
					// target might be given as string
					// -> convert to object selecting controller and its method by name
					let match = /^([^.]+)(?:\.(.+))?$/.exec( target.trim() );
					if ( !match ) {
						Debug( "invalid routing target selector %s", target );
						return null;
					}

					target = {
						controller: match[1],
						method:     match[2] || "index",
					};
					break;

				case "function" :
					// target might be given as function reference to invoke as-is
					return target;

				case "object" :
					// target is object selecting controller and its method by name
					if ( target && target.controller && target.method ) {
						break;
					}

					// falls through
				default :
					Debug( "invalid routing target descriptor %s", target );
					return null;
			}

			// at this point there is an object describing controller and method
			// of routing target

			// reduce optional suffix in name of controller selecting controller/policy
			target.controller = target.controller.replace( processPolicies ? /policy$/i : /controller$/i, "" ).toLowerCase();

			// check if selected controller exists
			let implementations = api.runtime[processPolicies ? "policies" : "controllers"];
			if ( !implementations.hasOwnProperty( target.controller ) ) {
				Debug( "ignoring route to missing %s %s (%s of %d@%s)", processPolicies ? "policy" : "controller", target.controller );
				return null;
			}

			// selected method must be provided by found controller
			let action = implementations[target.controller][target.method];
			if ( typeof action !== "function" ) {
				Debug( "ignoring route to missing %s action %s.%s (%s of %d@%s)", processPolicies ? "policy" : "controller", target.controller, target.method );
				return null;
			}

			return action;
		}
	}

	/**
	 * Reorganizes segmented list of routings to improve traversal time on
	 * dispatching requests later.
	 *
	 * The method is grouping requests by HTTP method routes are registered for.
	 * Furthermore it
	 *
	 * @param {HitchyRouteSet[]} segments
	 * @param {string[]} methods all HTTP methods used by at least one route
	 * @returns {HitchyRouteSetsPerMethod} maps http method name into set of attached routes
	 * @private
	 */
	function _groupByMethodAndPrefix( segments, methods ) {
		let groups = {};

		// prepare segmented list of routes per supported HTTP method
		let numMethods = methods.length;
		for ( let i = 0; i < numMethods; i++ ) {
			groups[methods[i]] = [];
		}

		for ( let segmentIndex = 0, length = segments.length; segmentIndex < length; segmentIndex++ ) {
			let segment = segments[segmentIndex];

			// locally group routes of current segments by HTTP method
			let localGroups = {};
			for ( let i = 0; i < numMethods; i++ ) {
				localGroups[methods[i]] = []
			}

			for ( let i = 0, numRoutes = segment.length; i < numRoutes; i++ ) {
				let route = segment[i];
				localGroups[route.method].push( route );
			}

			// group all routes in current segment of a single method
			for ( let i = 0; i < numMethods; i++ ) {
				let method = methods[i];

				groups[method].push( _groupByPrefix( localGroups[method] ) );
			}
		}

		return groups;


		/**
		 * Reorganizes a set of routes to be group by common prefix.
		 *
		 * All provided routes are considered to belong to single component and
		 * to be either associated with the same HTTP method or not to be
		 * associated with any HTTP method at all.
		 *
		 * This method is sorting list of routes from longest static prefix to
		 * shortest one. If any two routes have same size of prefix they are
		 * sorted alphabetically. This sorted list of routes is then split into
		 * segmented list of routes with segment related to a common prefix.
		 *
		 * @param routes
		 * @returns {Array}
		 * @private
		 */
		function _groupByPrefix( routes ) {
			let groups   = [],
				group    = null,
				previous = null;

			routes
				.sort( _sortFromLongestPrefixToShortest )
				.forEach( _deployIntoGroupPerPrefix );

			return groups;


			function _sortFromLongestPrefixToShortest( l, r ) {
				let ll = l.prefix.length;
				let rl = r.prefix.length;

				if ( rl != ll ) {
					return rl - ll;
				}

				return l.prefix.toLowerCase().localeCompare( r.prefix.toLowerCase() );
			}

			function _deployIntoGroupPerPrefix( route ) {
				let prefix = route.prefix;
				if ( prefix !== previous ) {
					// due to having sorted prefixes by name any previous prefix
					// has been deployed completely
					// -> start another group on new prefix
					previous = prefix;

					group = [];
					groups.push( group );
				}

				group.push( route );
			}
		}
	}
};





/**
 * Describes partially meta information provided by source parser for naming
 * and preprocessing parameters embedded into request path.
 *
 * @typedef {object} HitchyRouteParameterKey
 * @property {string} name name of parameter to use in `req.params`
 * @property {boolean} repeat true if related match might describe multiple
 *           values delimited by HitchyRouteParameterKeys#delimiter.
 * @property {string} delimiter delimiter for splitting repeated parameters
 */

/**
 * Describes router tables as provided by modules discovered and loaded as
 * hitchy components.
 *
 * @typedef {object} HitchyRouteComponentTables
 * @property {HitchyRouteDescriptorSet} [before]
 * @property {HitchyRouteDescriptorSet} [after]
 */

/**
 * Describes source of route.
 *
 * Every such source descriptor consists of URL path to be matched, optionally
 * preceded by HTTP method to be required for matching this route.
 *
 * * HTTP method might be omitted to match any method.
 * * URL path may use patterns for extracting named parameters embedded in URL.
 *
 * @typedef {string} HitchyRouteSourceDescriptor
 */

/**
 * Describes simple target selector.
 *
 * Simple selector strings contain name of controller and name of controller's
 * method separated by single period.
 *
 * @typedef {string} HitchyRouteTargetDescriptorSimple
 */

/**
 * Describes method of controller to be invoked on matching some route.
 *
 * @typedef {object} HitchyRouteTargetDescriptorComplex
 * @property {string} controller name of controller
 * @property {string} method name of controller's method to invoke on matching route
 */

/**
 * Describes some method to invoked on matching route using reference on
 * function itself.
 *
 * @typedef {HitchyRouteTargetFilter|HitchyRouteTargetResponder} HitchyRouteTargetDescriptorReference
 */

/**
 * Combines all sorts of probable route target descriptors.
 *
 * @typedef {HitchyRouteTargetDescriptorSimple|HitchyRouteTargetDescriptorComplex|HitchyRouteTargetDescriptorReference} HitchyRouteTargetDescriptor
 */

/**
 * Maps descriptions of route sources into related targets to be invoked on
 * matching source.
 *
 * @typedef {object<HitchyRouteSourceDescriptor,HitchyRouteTargetDescriptor>} HitchyRouteDescriptorSet
 */

// --- parsed route types ---

/**
 * Describes part of route to be matched against some actual URL path for
 * choosing related route on match.
 *
 * @typedef {object} HitchyRouteSource
 * @property {string} method HTTP method route is bound to (might be ALL or *)
 * @property {string} prefix initial static part of URL path to match
 * @property {RegExp} pattern pattern to test actual URL path for match
 * @property {HitchyRouteParameterKey[]} keys
 */

/**
 * Describes function to be invoked on matching some related route source to
 * preprocess or filter some request prior to processing target.
 *
 * @typedef {function(this:HitchyRequestContext, request:IncomingMessage, response:ServerResponse, next:function(error:Error=)=):?Promise} HitchyRouteTargetFilter
 */

/**
 * Describes function to be invoked on matching some related route source.
 *
 * @typedef {function(this:HitchyRequestContext, request:IncomingMessage, response:ServerResponse):?Promise} HitchyRouteTargetResponder
 */

/**
 * Combines a source to be tested on some actual URL path with function to be
 * invoked on matching for preprocessing matching request.
 *
 * @typedef {object} HitchyRouteFilter
 * @extends {HitchyRouteSource}
 * @property {HitchyRouteTargetFilter} target
 */

/**
 * Combines a source to be tested on some actual URL path with function to be
 * invoked on matching for responding eventually to matching request.
 *
 * @typedef {object} HitchyRouteResponder
 * @extends {HitchyRouteSource}
 * @property {HitchyRouteTargetResponder} target
 */

/**
 * Describes single route prepared for improved processing.
 *
 * @typedef {HitchyRouteFilter|HitchyRouteResponder} HitchyRoute
 */

/**
 * Described ordered set of prepared routes.
 *
 * @typedef {HitchyRoute[]} HitchyRouteSet
 */

/**
 * Described set of ordered sets of prepared routes.
 *
 * @typedef {HitchyRouteSet[]} HitchyRouteSets
 */

/**
 * Described map of HTTP method into one or more sets each consisting of a set
 * of prepared routes.
 *
 * @typedef {object<string,HitchyRouteSets>} HitchyRouteSetsPerMethod
 */

