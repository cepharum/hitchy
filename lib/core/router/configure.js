/**
 * (c) 2017 cepharum GmbH, Berlin, http://cepharum.de
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 cepharum GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @author: cepharum
 */

const Parser = require( "path-to-regexp" );
const Debug  = require( "debug" )( "debug" );

/**
 * Provides router processing some current request using configured routes.
 *
 * @this HitchyAPI
 * @param {HitchyOptions} options
 * @returns {Function}
 */
module.exports = function( options ) {
	const api = this;

	return _routerConfigure;



	/**
	 * Initializes sorted routing table from routes provided in configuration
	 *
	 * @param {HitchyComponentHandle[]} modules
	 * @param {HitchyRouteModuleTables[]} modulePolicies
	 * @param {HitchyRouteModuleTables[]} moduleRoutes
	 */
	function _routerConfigure( modules, modulePolicies, moduleRoutes ) {
		let methods, sequence;

		// compile routes selecting policies to process on every request
		methods = {};

		sequence = _combineIntoList( modulePolicies, true );
		sequence = _normalizeList( sequence, modules, methods, true );

		api.router.policies = _groupByMethod( sequence, Object.keys( methods ) );


		// compile routes selecting responder
		methods = {};

		sequence = _combineIntoList( moduleRoutes, false );
		sequence = _normalizeList( sequence, modules, methods, false );

		api.router.routes = _groupByMethod( sequence, Object.keys( methods ) );
	}

	/**
	 * Combines routes defined by discovered modules with custom routes in
	 * current project and blueprint routes injected due to controllers found in
	 * project and modules.
	 *
	 * @param {HitchyRouteModuleTables[]} routesPerModule
	 * @param {boolean} processPolicies true to process policies' definitions
	 * @returns {HitchyRouteDescriptorSet[]}
	 * @private
	 */
	function _combineIntoList( routesPerModule, processPolicies ) {
		let length = routesPerModule.length;
		let merged = new Array( length * 2 + 2 );
		let beforeIndex = 0;
		let afterIndex = length + 2;

		// simultaneously deploy before- and after-routes of modules to start &
		// end of resulting list
		for ( ; beforeIndex < length; beforeIndex++, afterIndex++ ) {
			let routes = routesPerModule[beforeIndex] || {};

			merged[beforeIndex] = routes.before || {};
			merged[afterIndex] = routes.after || {};
		}

		// insert project's custom routes right before ...
		merged[beforeIndex++] = api.runtime.config[processPolicies ? "policies" : "routes"] || {};

		// ... blueprint routes generated by optionally available model component
		merged[beforeIndex] = api.components.model && api.components.model[processPolicies ? "policies" : "routes"]() || {};


		return merged;
	}


	/**
	 * Normalizes every route in every segment to have equivalent structure for
	 * every route.
	 *
	 * @param {HitchyRouteDescriptorSet[]} segments
	 * @param {HitchyComponentHandle[]} modules
	 * @param {object<string,boolean>} methods collects all methods used in processed routes
	 * @param {boolean} processPolicies true to process policies' definitions
	 * @returns {HitchyRouteDescriptorSet[]}
	 * @private
	 */
	function _normalizeList( segments, modules, methods, processPolicies ) {
		let sindex, slength, segment,
		    rindex, rlength, sources, source,
		    method, listed, write;

		let routePtn  = /^(?:(\S+)\s+)?(\/.*)$/;
		let prefixPtn = /^([^*(:]*)/;

		let names = modules.map( module => module.name );

		names = names.concat( "<project>", "<blueprint>" ).concat( names );

		for ( sindex = 0, slength = segments.length; sindex < slength; sindex++ ) {
			// compile every route in current segment, drop invalid routes
			segment = segments[sindex];

			sources = Object.keys( segment );

			rlength = sources.length;
			listed  = new Array( rlength );

			for ( rindex = 0, write = 0; rindex < rlength; rindex++ ) {
				// compile single route
				source = sources[rindex];

				let route = _compileRouteSource( source );
				if ( route ) {
					route.target = _compileTarget( segment[source], processPolicies );
					if ( route.target ) {
						route.component = names[sindex];
						listed[write++] = route;
					}
				}
			}

			listed.splice( write, rlength - write );

			segments[sindex] = listed;
		}

		return segments;


		/**
		 * Creates route source from provided source description.
		 *
		 * @param {string} pattern
		 * @returns {?HitchyRouteSource}
		 * @private
		 */
		function _compileRouteSource( pattern ) {
			let match = routePtn.exec( String( pattern || "" ).trim() );
			if ( !match ) {
				Debug( "ignoring invalid route %s at %d@%s", pattern, sindex, rindex, names[sindex] );
				return null;
			}

			// extract method selected in route
			method = match[1] !== undefined ? match[1].toUpperCase() : false;
			if ( !method || method === "ALL" ) {
				method = "*";
			}

			// track all methods used in routes
			methods[method] = true;

			let route = {
				method: method,
			};

			let keys = [];
			let parsed = Parser( match[2], route.keys, {
				sensitive: true,    // match path case-sensitively
			} );

			match = prefixPtn.exec( match[2] );
			let prefix = match[1].replace( /\/$/, "" );

			return { method, pattern: parsed, keys, prefix };
		}

		/**
		 *
		 * @param {HitchyRouteTargetDescriptor} target
		 * @param {boolean} processPolicies true to process policies' definitions
		 * @returns {?HitchyRouteTargetDescriptorReference}
		 * @private
		 */
		function _compileTarget( target, processPolicies ) {
			// target might be given as string
			// -> convert to object selecting controller and its method by name
			if ( typeof target === "string" ) {
				let match = /^([^.]+)(?:\.(.+))?$/.exec( target.trim() );
				if ( !match ) {
					Debug( "invalid target selector %s on route %s of %d@%s", target, source, rindex, names[sindex] );
					return null;
				}

				target = {
					controller: match[1],
					method:     match[2] || "index",
				};
			}

			// target might be given as function reference to invoke as-is
			if ( typeof target === "function" ) {
				return target;
			}

			// target must be eventually given as object selecting controller
			// and its method by name
			if ( !target || typeof target !== "object" || !target.controller || !target.method ) {
				Debug( "invalid target descriptor on route %s of at %d@%s", target, source, rindex, names[sindex] );
				return null;
			}

			target.controller = target.controller.replace( processPolicies ? /policy$/i : /controller$/i, "" ).toLowerCase();

			// selected controller must exist
			let implementations = api.runtime[processPolicies ? "policies" : "controllers"];

			if ( !implementations.hasOwnProperty( target.controller ) ) {
				Debug( "ignoring route to missing %s %s (%s of %d@%s)", processPolicies ? "policy" : "controller", target.controller, source, rindex, names[sindex] );
				return null;
			}

			// selected method must be provided by selected controller
			let action = implementations[target.controller][target.method];
			if ( typeof action !== "function" ) {
				Debug( "ignoring route to missing %s action %s.%s (%s of %d@%s)", processPolicies ? "policy" : "controller", target.controller, target.method, source, rindex, names[sindex] );
				return null;
			}

			return action;
		}
	}

	/**
	 * Rearranges list of routing sets into map of HTTP method name into routing
	 * set limited to routes attached to either method, only.
	 *
	 * @param {HitchyRouteSet[]} segments
	 * @param {string[]} methods all HTTP methods used by at least one route
	 * @returns {HitchyRouteSetsPerMethod} maps http method name into set of attached routes
	 * @private
	 */
	function _groupByMethod( segments, methods ) {
		let groups    = {},
		    groupRefs,
		    mindex, mlength, method,
		    sindex, slength, segment,
		    rindex, rlength, route;

		// collect all actually used HTTP methods and prepare groups accordingly
		mlength = methods.length;

		// ensure to create one collection for every basically supported method
		// (to simplify iteration on request dispatching later)
		for ( mindex = 0; mindex < mlength; mindex++ ) {
			groups[methods[mindex]] = [];
		}

		for ( sindex = 0, slength = segments.length; sindex < slength; sindex++ ) {
			segment = segments[sindex];

			// always another collection for every basically supported method
			// (to simplify iteration on request dispatching later)
			groupRefs = {};
			for ( mindex = 0; mindex < mlength; mindex++ ) {
				groupRefs[methods[mindex]] = []
			}

			// deploy routes of current segment/component to separate
			// collections depending on either route's method
			for ( rindex = 0, rlength = segment.length; rindex < rlength; rindex++ ) {
				route = segment[rindex];

				groupRefs[route.method].push( route );
			}

			// group all deployed collections by prefix of contained routes
			// and push onto common collector per group
			for ( mindex = 0; mindex < mlength; mindex++ ) {
				method = methods[mindex];

				groups[method].push( _groupByPrefix( groupRefs[method] ) );
			}
		}

		return groups;


		/**
		 * Reorganizes a set of routes to be group by common prefix.
		 *
		 * @param routes
		 * @returns {Array}
		 * @private
		 */
		function _groupByPrefix( routes ) {
			let groups   = [],
				group    = null,
				previous = null;

			routes
				.sort( _sortFromLongestPrefixToShortest )
				.forEach( _deployIntoGroupPerPrefix );

			return groups;


			function _sortFromLongestPrefixToShortest( l, r ) {
				let ll = l.prefix.length;
				let rl = r.prefix.length;

				if ( rl != ll ) {
					return rl - ll;
				}

				return l.prefix.toLowerCase().localeCompare( r.prefix.toLowerCase() );
			}

			function _deployIntoGroupPerPrefix( route ) {
				let prefix = route.prefix;
				if ( prefix !== previous ) {
					// due to having sorted prefixes by name any previous prefix
					// has been deployed completely
					// -> start another group on new prefix
					previous = prefix;

					group = [];
					groups.push( group );
				}

				group.push( route );
			}
		}
	}
};





/**
 * Describes partially meta information provided by source parser for naming
 * and preprocessing parameters embedded into request path.
 *
 * @typedef {object} HitchyRouteParameterKey
 * @property {string} name name of parameter to use in `req.params`
 * @property {boolean} repeat true if related match might describe multiple
 *           values delimited by HitchyRouteParameterKeys#delimiter.
 * @property {string} delimiter delimiter for splitting repeated parameters
 */

/**
 * Describes router tables as provided by modules discovered and loaded as
 * hitchy components.
 *
 * @typedef {object} HitchyRouteModuleTables
 * @property {HitchyRouteDescriptorSet} [before]
 * @property {HitchyRouteDescriptorSet} [after]
 */

/**
 * Describes source of route.
 *
 * Every such source descriptor consists of URL path to be matched, optionally
 * preceded by HTTP method to be required for matching this route.
 *
 * * HTTP method might be omitted to match any method.
 * * URL path may use patterns for extracting named parameters embedded in URL.
 *
 * @typedef {string} HitchyRouteSourceDescriptor
 */

/**
 * Describes simple target selector.
 *
 * Simple selector strings contain name of controller and name of controller's
 * method separated by single period.
 *
 * @typedef {string} HitchyRouteTargetDescriptorSimple
 */

/**
 * Describes method of controller to be invoked on matching some route.
 *
 * @typedef {object} HitchyRouteTargetDescriptorComplex
 * @property {string} controller name of controller
 * @property {string} method name of controller's method to invoke on matching route
 */

/**
 * Describes some method to invoked on matching route using reference on
 * function itself.
 *
 * @typedef {HitchyRouteTargetFilter|HitchyRouteTargetResponder} HitchyRouteTargetDescriptorReference
 */

/**
 * Combines all sorts of probable route target descriptors.
 *
 * @typedef {HitchyRouteTargetDescriptorSimple|HitchyRouteTargetDescriptorComplex|HitchyRouteTargetDescriptorReference} HitchyRouteTargetDescriptor
 */

/**
 * Maps descriptions of route sources into related targets to be invoked on
 * matching source.
 *
 * @typedef {object<HitchyRouteSourceDescriptor,HitchyRouteTargetDescriptor>} HitchyRouteDescriptorSet
 */

// --- parsed route types ---

/**
 * Describes part of route to be matched against some actual URL path for
 * choosing related route on match.
 *
 * @typedef {object} HitchyRouteSource
 * @property {string} method HTTP method route is bound to (might be ALL or *)
 * @property {string} prefix initial static part of URL path to match
 * @property {RegExp} pattern pattern to test actual URL path for match
 * @property {HitchyRouteParameterKey[]} keys
 */

/**
 * Describes function to be invoked on matching some related route source to
 * preprocess or filter some request prior to processing target.
 *
 * @typedef {function(this:HitchyRequestContext, request:IncomingMessage, response:ServerResponse, next:function(error:Error=)=):?Promise} HitchyRouteTargetFilter
 */

/**
 * Describes function to be invoked on matching some related route source.
 *
 * @typedef {function(this:HitchyRequestContext, request:IncomingMessage, response:ServerResponse):?Promise} HitchyRouteTargetResponder
 */

/**
 * Combines a source to be tested on some actual URL path with function to be
 * invoked on matching for preprocessing matching request.
 *
 * @typedef {object} HitchyRouteFilter
 * @extends {HitchyRouteSource}
 * @property {HitchyRouteTargetFilter} target
 */

/**
 * Combines a source to be tested on some actual URL path with function to be
 * invoked on matching for responding eventually to matching request.
 *
 * @typedef {object} HitchyRouteResponder
 * @extends {HitchyRouteSource}
 * @property {HitchyRouteTargetResponder} target
 */

/**
 * Describes single route prepared for improved processing.
 *
 * @typedef {HitchyRouteFilter|HitchyRouteResponder} HitchyRoute
 */

/**
 * Described ordered set of prepared routes.
 *
 * @typedef {HitchyRoute[]} HitchyRouteSet
 */

/**
 * Described set of ordered sets of prepared routes.
 *
 * @typedef {HitchyRouteSet[]} HitchyRouteSets
 */

/**
 * Described map of HTTP method into one or more sets each consisting of a set
 * of prepared routes.
 *
 * @typedef {object<string,HitchyRouteSets>} HitchyRouteSetsPerMethod
 */

